\usemodule[vim]

% \enablemode[manuscript]
\enablemode[presentation]
\definevimtyping[Haskell][syntax=haskell,tab=2]                      
\definevimtyping [RUBY]  [syntax=ruby]
\setupcolors[state=start]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This is the markup for the manuscript.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\startmode[manuscript]
  \setvariables[contexts][ mono_font_size_small  =7pt
                         , mono_font_size_mid    =7pt
                         , mono_font_size_large  =7pt]
\setuppapersize[A4][A4]
\setupframedtexts[ location=middle,
                   before  ={\blank[line]},
                   after   ={\blank[line]} ]



\let\startSlide\startframedtext
\let\stopSlide\stopframedtext

\define[1]\SlideTitle{\midaligned{#1}\blank[small]}

\setupbackgrounds[page] [background={backgraphics,foreground}]

\stopmode


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% This is the markup for the presentation.
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\startmode[presentation]
\setuppapersize[S6][S6] 
\setvariables[contexts][ mono_font_size_small=9pt
                       , mono_font_size_mid    =9pt
                       , mono_font_size_large  =12pt]


\usetypescript[helvetica] [ec]
\setupbodyfont[helvetica,14pt]

\setuplayout [width=fit,
              rightmargin=1.5cm,
              leftmargin=1.5cm,
              leftmargindistance=0pt,
              rightmargindistance=0pt,
              height=fit, 
              header=0pt, 
              footer=5pt, 
              topspace=1.50cm, 
              backspace=1.5cm,
              bottomspace=.8cm,
              bottom=12pt,
              location=singlesided]

\setupcombinations[distance=0pt]

\setuppagenumber[state=stop]

\setupbackgrounds[page] [background={color,backgraphics,foreground},backgroundcolor=black]

\startcolor[white]

\definestartstop
   [Slide]
   [commands={\switchtobodyfont[20pt]},
    before=\page]

\define[1]\SlideTitle
  {\midaligned{\tfb #1}
   \blank[line]}

\define[1]\PresentationTitle
  {
   \blank[3*line]
   \midaligned{\tfb #1}
   \blank[line]}



\stopmode




\starttypescript [mono] [ProjectSourceCode]
  \definefontsynonym [Mono]     [name:inconsolata]
  \definefontsynonym [MonoBold] [name:inconsolatabold]
\stoptypescript

\definetypeface[ProjectFont] [tt] [mono]  [ProjectSourceCode] [default]

\usetypescript[ProjectFont] [ec]
% \setupbodyfont[ProjectFont]

\definefont[SourceCodeFont][Mono sa 0.45]

\setupvimtyping[
  style={\switchtobodyfont[ProjectFont,\getvariable{contexts}{mono_font_size_small}]},
]


































%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% START DOCUMENT
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\starttext











%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Title Slide
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\startSlide
  
\startmode[manuscript]
  Properties, types, and tests are words that are
  are often seen around the FP community.
\stopmode

\PresentationTitle{Properties! \\ And their relation to Types and Tests}
\stopSlide  









%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Examples of Property Definitions 
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\startSlide  
\startmode[manuscript]
  Properties can be defined either as those things which an
  object has or as those things which an object can do.

\stopmode
\SlideTitle{Two ways of looking at properties}
\startitemize
\item The things that define an object.
\startHaskell
-- | Product numbers  are: [[:alnum:]]
-- unicode enc
-- Max length 140
-- Min length 1 (can't be empty)
newtype ProductNumber = ProductNumber { _unProductNumber :: Text}    
  deriving (Show,Eq,Ord)
\stopHaskell    

\item The things that define what an object can do.
\startHaskell
-- | Product numbers  uniquely determine a particular product
-- They can be sorted and compared
newtype ProductNumber = ProductNumber { _unProductNumber :: Text}    
  deriving (Show,Eq,Ord)
\stopHaskell

\item We will mostly be talking about the first.
\stopitemize

\stopSlide  












%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Toolbox
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\startSlide
  
\startmode[manuscript]
  What we want to do with our types and tests is guarantee
  that when we say a thing has a property it really has it.

  You can of course do this with careful work in any programming
  language.  Typed functional programming languages endeavor to make the
  process quicker than others.  
\stopmode

\SlideTitle{The Haskell Toolbox \\ The skills to pay the bills.}
\startitemize
\item Type Encoding  
\item Smart Constructors
\item QuickCheck
\item Typed Transformation
\item LiquidTypes  
\stopitemize

\stopSlide  











%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Summary on the tools
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\startSlide
  
\startmode[manuscript]
  Use smart constructors, quick check and liquid types to ensure
  boundary condtions are verified and that the inherent
  mutability of code is respected.

  Use Type Encoding, Typed Transformation
  and LiquidTypes to ensure invariance once a property has been constructed.
  
\stopmode

\SlideTitle{The Pattern.}
The gist of what is going on...
\startitemize
\item   At the boundaries, use smart constructors and quick check to make sure
        types are built correctly.

\item Use Type Encoding, Type Transformation, QuickCheck, and immutability to add or change
      data  without having to recondtion it.

\stopitemize
\stopSlide  





\setupvimtyping[
  style={\switchtobodyfont[ProjectFont,11pt]},
]














%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Type Level Encoding
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\startSlide

  \startmode[manuscript]
    Type level encoding allows you to specify properties
    that might vary only slightly among a set of data.

    you wouldn't want to declare a 1000 real types for every
    possible vector length for instance.

    Type level encoding makes it possible to specify things
    at construction site instead of declaration site.
  \stopmode    
  
  \SlideTitle{Type Level Encoding \\ Put it where you can find it... }
  Create specific types to exactly match
  some set of properties. e.g. ...
  \blank[2*line]

  \startHaskell
newtype  FixedText (lengthMax :: Nat)    -- Says how big the text can be
                   (lengthMin :: Nat)    -- Says how small it is 
                   (regex     :: Symbol) -- What characters are allowable
              = FixedText { _unMyText :: Text}
  deriving (Show,Ord,Eq)
\stopHaskell


\stopSlide  

















\setupvimtyping[
  style={\switchtobodyfont[ProjectFont,\getvariable{contexts}{mono_font_size_small}]},
]


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Correct By Construction Definition Slide
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\startSlide
  
\startmode[manuscript]
FixedText encodes the min max and valid character set.  

\stopmode  
\SlideTitle{Correct By Construction!}  
\startHaskell

  -- | Guarantees FixedText will have fixed length
  --  and valid characters.  
fixedTextFromString :: forall max min regex . 
  ( KnownNat    max
  , KnownNat    min
  , KnownSymbol regex) =>
    String ->
    Either FixedTextErrors (FixedText max min regex)
    
fixedTextFromString str = final
  where
    max'          = fromIntegral $ natVal (Proxy :: Proxy max)
    min'          = fromIntegral $ natVal (Proxy :: Proxy min)    
    isTooLittle   = length str < min'
    regexStr      = symbolVal (Proxy :: Proxy regex)
    trimmedString = take max' str
    notRegex      = notValidRegex regexStr trimmedString
    final
      | isTooLittle = Left   FixedTextErrorMin
      | notRegex    = Left   (FixedTextErrorRegex regexStr trimmedString)
      | otherwise   = Right . FixedText .   pack $ trimmedString  
\stopHaskell  
\stopSlide


















%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Correct By Construction Example Slide
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\startSlide
  
\startmode[manuscript]
  Here are a few examples of working and rejected FixedText
  constructions.
\stopmode  
\SlideTitle{Examples!}  
\startHaskell
-- | Just works, example
exampleFixedText  :: Either FixedTextErrors (FixedText 30 1 "[[:alnum:]]")
exampleFixedText = fixedTextFromString "exampleText1234" 
$> exampleFixedText
Right (FixedText {_unFixedText = "exampleText1234"})

-- | Cut off too much input.
exampleOverFlowProtection :: Either FixedTextErrors (FixedText 10 1 "[[:alnum:]]")
exampleOverFlowProtection = fixedTextFromString "exampleText1234" 
$> exampleOverFlowProtection
Right (FixedText {_unFixedText = "exampleTex"})


-- | Reject if invalid char
exampleInvalidChar :: Either FixedTextErrors (FixedText 30 1 "[[:digit:]]")
exampleInvalidChar = fixedTextFromString "exampleNotAllDigits"
$> exampleInvalidChar
Left (FixedTextErrorRegex "[[:digit:]]" "exampleNotAllDigits")

\stopHaskell  
\stopSlide



\setupvimtyping[
  style={\switchtobodyfont[ProjectFont, 12pt]},
]



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Adding a Monoid Instance
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\startSlide
\startmode[manuscript]
  I want to define a few more instances with this Fixed Text type.

  First a Monoid instance, which requires associativity and an identity
  for that associative operator.

  The only Monoid that makes sense fixes the min length at 0.
  We could define a semigroup but that isn't part of base.
  
\stopmode
\SlideTitle{Make Mine a Monoid}

\blank[2*line]
\startHaskell
-- | Monoid instance with 0 min
-- No FixedText besides one that has a minimum size of zero
-- should be a Monoid.
instance (KnownNat max, KnownSymbol regex) => 
 Monoid (FixedText (max::Nat) (0::Nat) (regex::Symbol)) where
  mempty  = FixedText ""
  mappend s1@(FixedText str1) (FixedText str2) =
      either (const s1)
             id
             (fixedTextFromText (str1 <> str2))
\stopHaskell

\stopSlide  



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Check our Constructor With QuickCheck
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\startSlide
\startmode[manuscript]

  Our handful of examples do well to convince us that our implementation of FixedText
  looks correct.  One thing that is interesting is part of the correctness of this
  type relies on the correct implementation of a regular expression which is
  very hard to prove.

  When things are sufficiently dynamic, we might want one more layer to protect against
  program changes and unexpected behavior.  To this end let's use QuickCheck to build a
  test.     
\stopmode
\SlideTitle{All Code is Mutable!}
\startHaskell
-- | Arbitrary instance
-- This arbitrary instance takes advantage of the Monoid defined above
instance forall max regex . ( KnownNat     max
                            , KnownSymbol  regex) => 
  Arbitrary (FixedText (max::Nat) (0::Nat) (regex::Symbol)) where
    arbitrary = let max'            = fromIntegral $ natVal (Proxy :: Proxy max)
                    regexStr        = symbolVal (Proxy :: Proxy regex)        
                    generatedString = Genex.genexPure [regexStr]

                 in either (const mempty) id <$>
                            QuickCheck.elements
                              (fixedTextFromString <$>
                                         generatedString)





\stopHaskell  
\stopSlide  





\stoptext



   

